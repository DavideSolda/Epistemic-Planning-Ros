//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"

/********************   Prg    ********************/
Prg::Prg(ListDecl *p1)
{
  listdecl_ = p1;

}

Prg::Prg(const Prg & other)
{
  listdecl_ = other.listdecl_->clone();

}

Prg &Prg::operator=(const Prg & other)
{
  Prg tmp(other);
  swap(tmp);
  return *this;
}

void Prg::swap(Prg & other)
{
  std::swap(listdecl_, other.listdecl_);

}

Prg::~Prg()
{
  delete(listdecl_);

}

void Prg::accept(Visitor *v)
{
  v->visitPrg(this);
}

Prg *Prg::clone() const
{
  return new Prg(*this);
}



/********************   Def    ********************/
Def::Def(Ident p1, Ident p2)
{
  ident_1 = p1;
  ident_2 = p2;

}

Def::Def(const Def & other)
{
  ident_1 = other.ident_1;
  ident_2 = other.ident_2;

}

Def &Def::operator=(const Def & other)
{
  Def tmp(other);
  swap(tmp);
  return *this;
}

void Def::swap(Def & other)
{
  std::swap(ident_1, other.ident_1);
  std::swap(ident_2, other.ident_2);

}

Def::~Def()
{

}

void Def::accept(Visitor *v)
{
  v->visitDef(this);
}

Def *Def::clone() const
{
  return new Def(*this);
}



/********************   Exec    ********************/
Exec::Exec(Action *p1, ListLiteral *p2)
{
  action_ = p1;
  listliteral_ = p2;

}

Exec::Exec(const Exec & other)
{
  action_ = other.action_->clone();
  listliteral_ = other.listliteral_->clone();

}

Exec &Exec::operator=(const Exec & other)
{
  Exec tmp(other);
  swap(tmp);
  return *this;
}

void Exec::swap(Exec & other)
{
  std::swap(action_, other.action_);
  std::swap(listliteral_, other.listliteral_);

}

Exec::~Exec()
{
  delete(action_);
  delete(listliteral_);

}

void Exec::accept(Visitor *v)
{
  v->visitExec(this);
}

Exec *Exec::clone() const
{
  return new Exec(*this);
}



/********************   Caus    ********************/
Caus::Caus(Action *p1, ListLiteral *p2)
{
  action_ = p1;
  listliteral_ = p2;

}

Caus::Caus(const Caus & other)
{
  action_ = other.action_->clone();
  listliteral_ = other.listliteral_->clone();

}

Caus &Caus::operator=(const Caus & other)
{
  Caus tmp(other);
  swap(tmp);
  return *this;
}

void Caus::swap(Caus & other)
{
  std::swap(action_, other.action_);
  std::swap(listliteral_, other.listliteral_);

}

Caus::~Caus()
{
  delete(action_);
  delete(listliteral_);

}

void Caus::accept(Visitor *v)
{
  v->visitCaus(this);
}

Caus *Caus::clone() const
{
  return new Caus(*this);
}



/********************   CausCond    ********************/
CausCond::CausCond(Action *p1, ListLiteral *p2, ListLiteral *p3)
{
  action_ = p1;
  listliteral_1 = p2;
  listliteral_2 = p3;

}

CausCond::CausCond(const CausCond & other)
{
  action_ = other.action_->clone();
  listliteral_1 = other.listliteral_1->clone();
  listliteral_2 = other.listliteral_2->clone();

}

CausCond &CausCond::operator=(const CausCond & other)
{
  CausCond tmp(other);
  swap(tmp);
  return *this;
}

void CausCond::swap(CausCond & other)
{
  std::swap(action_, other.action_);
  std::swap(listliteral_1, other.listliteral_1);
  std::swap(listliteral_2, other.listliteral_2);

}

CausCond::~CausCond()
{
  delete(action_);
  delete(listliteral_1);
  delete(listliteral_2);

}

void CausCond::accept(Visitor *v)
{
  v->visitCausCond(this);
}

CausCond *CausCond::clone() const
{
  return new CausCond(*this);
}



/********************   Init    ********************/
Init::Init(Literal *p1)
{
  literal_ = p1;

}

Init::Init(const Init & other)
{
  literal_ = other.literal_->clone();

}

Init &Init::operator=(const Init & other)
{
  Init tmp(other);
  swap(tmp);
  return *this;
}

void Init::swap(Init & other)
{
  std::swap(literal_, other.literal_);

}

Init::~Init()
{
  delete(literal_);

}

void Init::accept(Visitor *v)
{
  v->visitInit(this);
}

Init *Init::clone() const
{
  return new Init(*this);
}



/********************   Final    ********************/
Final::Final(Literal *p1)
{
  literal_ = p1;

}

Final::Final(const Final & other)
{
  literal_ = other.literal_->clone();

}

Final &Final::operator=(const Final & other)
{
  Final tmp(other);
  swap(tmp);
  return *this;
}

void Final::swap(Final & other)
{
  std::swap(literal_, other.literal_);

}

Final::~Final()
{
  delete(literal_);

}

void Final::accept(Visitor *v)
{
  v->visitFinal(this);
}

Final *Final::clone() const
{
  return new Final(*this);
}



/********************   Preds    ********************/
Preds::Preds(Ident p1, ListExp *p2)
{
  ident_ = p1;
  listexp_ = p2;

}

Preds::Preds(const Preds & other)
{
  ident_ = other.ident_;
  listexp_ = other.listexp_->clone();

}

Preds &Preds::operator=(const Preds & other)
{
  Preds tmp(other);
  swap(tmp);
  return *this;
}

void Preds::swap(Preds & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listexp_, other.listexp_);

}

Preds::~Preds()
{
  delete(listexp_);

}

void Preds::accept(Visitor *v)
{
  v->visitPreds(this);
}

Preds *Preds::clone() const
{
  return new Preds(*this);
}



/********************   Pred    ********************/
Pred::Pred(Ident p1)
{
  ident_ = p1;

}

Pred::Pred(const Pred & other)
{
  ident_ = other.ident_;

}

Pred &Pred::operator=(const Pred & other)
{
  Pred tmp(other);
  swap(tmp);
  return *this;
}

void Pred::swap(Pred & other)
{
  std::swap(ident_, other.ident_);

}

Pred::~Pred()
{

}

void Pred::accept(Visitor *v)
{
  v->visitPred(this);
}

Pred *Pred::clone() const
{
  return new Pred(*this);
}



/********************   LitN    ********************/
LitN::LitN(Predicate *p1)
{
  predicate_ = p1;

}

LitN::LitN(const LitN & other)
{
  predicate_ = other.predicate_->clone();

}

LitN &LitN::operator=(const LitN & other)
{
  LitN tmp(other);
  swap(tmp);
  return *this;
}

void LitN::swap(LitN & other)
{
  std::swap(predicate_, other.predicate_);

}

LitN::~LitN()
{
  delete(predicate_);

}

void LitN::accept(Visitor *v)
{
  v->visitLitN(this);
}

LitN *LitN::clone() const
{
  return new LitN(*this);
}



/********************   Lit    ********************/
Lit::Lit(Predicate *p1)
{
  predicate_ = p1;

}

Lit::Lit(const Lit & other)
{
  predicate_ = other.predicate_->clone();

}

Lit &Lit::operator=(const Lit & other)
{
  Lit tmp(other);
  swap(tmp);
  return *this;
}

void Lit::swap(Lit & other)
{
  std::swap(predicate_, other.predicate_);

}

Lit::~Lit()
{
  delete(predicate_);

}

void Lit::accept(Visitor *v)
{
  v->visitLit(this);
}

Lit *Lit::clone() const
{
  return new Lit(*this);
}



/********************   LitE    ********************/
LitE::LitE(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

LitE::LitE(const LitE & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

LitE &LitE::operator=(const LitE & other)
{
  LitE tmp(other);
  swap(tmp);
  return *this;
}

void LitE::swap(LitE & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

LitE::~LitE()
{
  delete(exp_1);
  delete(exp_2);

}

void LitE::accept(Visitor *v)
{
  v->visitLitE(this);
}

LitE *LitE::clone() const
{
  return new LitE(*this);
}



/********************   LitNE    ********************/
LitNE::LitNE(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

LitNE::LitNE(const LitNE & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

LitNE &LitNE::operator=(const LitNE & other)
{
  LitNE tmp(other);
  swap(tmp);
  return *this;
}

void LitNE::swap(LitNE & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

LitNE::~LitNE()
{
  delete(exp_1);
  delete(exp_2);

}

void LitNE::accept(Visitor *v)
{
  v->visitLitNE(this);
}

LitNE *LitNE::clone() const
{
  return new LitNE(*this);
}



/********************   Acts    ********************/
Acts::Acts(Ident p1, ListExp *p2)
{
  ident_ = p1;
  listexp_ = p2;

}

Acts::Acts(const Acts & other)
{
  ident_ = other.ident_;
  listexp_ = other.listexp_->clone();

}

Acts &Acts::operator=(const Acts & other)
{
  Acts tmp(other);
  swap(tmp);
  return *this;
}

void Acts::swap(Acts & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listexp_, other.listexp_);

}

Acts::~Acts()
{
  delete(listexp_);

}

void Acts::accept(Visitor *v)
{
  v->visitActs(this);
}

Acts *Acts::clone() const
{
  return new Acts(*this);
}



/********************   Act    ********************/
Act::Act(Ident p1)
{
  ident_ = p1;

}

Act::Act(const Act & other)
{
  ident_ = other.ident_;

}

Act &Act::operator=(const Act & other)
{
  Act tmp(other);
  swap(tmp);
  return *this;
}

void Act::swap(Act & other)
{
  std::swap(ident_, other.ident_);

}

Act::~Act()
{

}

void Act::accept(Visitor *v)
{
  v->visitAct(this);
}

Act *Act::clone() const
{
  return new Act(*this);
}



/********************   EAdd    ********************/
EAdd::EAdd(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EAdd::EAdd(const EAdd & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EAdd &EAdd::operator=(const EAdd & other)
{
  EAdd tmp(other);
  swap(tmp);
  return *this;
}

void EAdd::swap(EAdd & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAdd::~EAdd()
{
  delete(exp_1);
  delete(exp_2);

}

void EAdd::accept(Visitor *v)
{
  v->visitEAdd(this);
}

EAdd *EAdd::clone() const
{
  return new EAdd(*this);
}



/********************   ESub    ********************/
ESub::ESub(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ESub::ESub(const ESub & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ESub &ESub::operator=(const ESub & other)
{
  ESub tmp(other);
  swap(tmp);
  return *this;
}

void ESub::swap(ESub & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ESub::~ESub()
{
  delete(exp_1);
  delete(exp_2);

}

void ESub::accept(Visitor *v)
{
  v->visitESub(this);
}

ESub *ESub::clone() const
{
  return new ESub(*this);
}



/********************   EMul    ********************/
EMul::EMul(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EMul::EMul(const EMul & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EMul &EMul::operator=(const EMul & other)
{
  EMul tmp(other);
  swap(tmp);
  return *this;
}

void EMul::swap(EMul & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EMul::~EMul()
{
  delete(exp_1);
  delete(exp_2);

}

void EMul::accept(Visitor *v)
{
  v->visitEMul(this);
}

EMul *EMul::clone() const
{
  return new EMul(*this);
}



/********************   EDiv    ********************/
EDiv::EDiv(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EDiv::EDiv(const EDiv & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EDiv &EDiv::operator=(const EDiv & other)
{
  EDiv tmp(other);
  swap(tmp);
  return *this;
}

void EDiv::swap(EDiv & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EDiv::~EDiv()
{
  delete(exp_1);
  delete(exp_2);

}

void EDiv::accept(Visitor *v)
{
  v->visitEDiv(this);
}

EDiv *EDiv::clone() const
{
  return new EDiv(*this);
}



/********************   EMod    ********************/
EMod::EMod(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EMod::EMod(const EMod & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EMod &EMod::operator=(const EMod & other)
{
  EMod tmp(other);
  swap(tmp);
  return *this;
}

void EMod::swap(EMod & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EMod::~EMod()
{
  delete(exp_1);
  delete(exp_2);

}

void EMod::accept(Visitor *v)
{
  v->visitEMod(this);
}

EMod *EMod::clone() const
{
  return new EMod(*this);
}



/********************   EInt    ********************/
EInt::EInt(Integer p1)
{
  integer_ = p1;

}

EInt::EInt(const EInt & other)
{
  integer_ = other.integer_;

}

EInt &EInt::operator=(const EInt & other)
{
  EInt tmp(other);
  swap(tmp);
  return *this;
}

void EInt::swap(EInt & other)
{
  std::swap(integer_, other.integer_);

}

EInt::~EInt()
{

}

void EInt::accept(Visitor *v)
{
  v->visitEInt(this);
}

EInt *EInt::clone() const
{
  return new EInt(*this);
}



/********************   EIdent    ********************/
EIdent::EIdent(Ident p1)
{
  ident_ = p1;

}

EIdent::EIdent(const EIdent & other)
{
  ident_ = other.ident_;

}

EIdent &EIdent::operator=(const EIdent & other)
{
  EIdent tmp(other);
  swap(tmp);
  return *this;
}

void EIdent::swap(EIdent & other)
{
  std::swap(ident_, other.ident_);

}

EIdent::~EIdent()
{

}

void EIdent::accept(Visitor *v)
{
  v->visitEIdent(this);
}

EIdent *EIdent::clone() const
{
  return new EIdent(*this);
}




/********************   ListLiteral    ********************/

void ListLiteral::accept(Visitor *v)
{
  v->visitListLiteral(this);
}


ListLiteral *ListLiteral::clone() const
{
  return new ListLiteral(*this);
}


/********************   ListIdent    ********************/

void ListIdent::accept(Visitor *v)
{
  v->visitListIdent(this);
}


ListIdent *ListIdent::clone() const
{
  return new ListIdent(*this);
}


/********************   ListExp    ********************/

void ListExp::accept(Visitor *v)
{
  v->visitListExp(this);
}


ListExp *ListExp::clone() const
{
  return new ListExp(*this);
}


/********************   ListDecl    ********************/

void ListDecl::accept(Visitor *v)
{
  v->visitListDecl(this);
}


ListDecl *ListDecl::clone() const
{
  return new ListDecl(*this);
}




